<< /Typed Functional Programming

Functional Programming is all about:

  - Modularity: functions as modules
  - Composability: functions are composable (the best composable unit)
  - Modeling programs as data: `What` instead of `How`, expressions instead of statements
```
{
  def imperativeProgram(): Unit = {
    var i: Int = 0
    
    i = i + 2
    i = i * 3
    println(i)
  }
  // Main
  imperativeProgram
}
```
--
```

object typedFP {
  
  def fpProgram(logger: Any => Unit)(inc: Int => Int, mul: Int => Int): Int => Unit =
    logger compose mul compose inc 

  val program = fpProgram {println _} (_ + 2, _ * 3)
}

typedFP.program(0)
```
---
<< /Typed Functional Programming/ADTs

If we have:
  + types (as a set of values)
  + functions (as pure operations between those values)
  + laws (as properties to be sustained by those operations)
that conforms an \*Algebra\s!
The word \*Algebra\s appears again and again in functional programming.
For example, all the common data structures (Semigroup, Monoid, Functor, Applicative, Monad,...)
are Algebras. The `kind of type` mainly used in FP are the \*Algebraic Data Types\s(ADTs).

An ADT is the algebra generated by types(as its values) and Sum/Product(as its operations),
and the derived laws from this ops. An example:

```
// Bool is CoProduct(alias Sum) of type True and False
sealed trait Bool
final case object True
final case object False

// ADTs could be recursive:
sealed trait List[+A]
case object Nil extends List[Nothing]
case class ::[A](head: A, tail: List[A]) extends List[A]
```
---
<< /Typed Functional Programming/ADTs

Boolean = true | false
Int = 1 | 2 | 3 | ...
Unit = ()

\*Type Cardinality:

  Nothing = 0  Unit = 1 Boolean = 2  Byte = 256

  (Byte, Boolean) 多?     (Byte, Unit, Unit)?
--

  (256, 2) = 256 x 2     (256, 1, 1) = 256 x 1 x 1
--

  (Unit => Boolean) 多?   (Boolean => Byte) 多?
--

  (1 => 2) = 2^1         (2 => 256) = 256^2
--

  \*And [A](Nothing => A) 多?


<< http://tpolecat.github.io/presentations/algebraic_types.html
---
<< /Typed Functional Programming/ADTs

In Scala Products are usually represented as:
  - case classes (=:= 'named' tuples)
  - using HLists from Shapeless for a more generic way

--

In Scala Sums or CoProducts are usually represented as:
  - sealed trait + final case clas/object
  - Coproduct representations as in Shapeless, FreeK, Freestyle,...

---
<< /Typed Functional Programming/Purity

Another 'controversial' point is \*purity\s.

But, what's a \*pure\s function?
--

Usually are defined as functions without any other 'effect' that its result values and
that only depends on its input. Another way of say that, is that \*are memoizable functions\s.
Pure functions must be \*total\s: must yield a value for every possible input.

With this definition, our functions can be thought as a \*mathematical functions\s.

Pure functions:
  - Not throw exceptions --> only return its output type
  - Not mutate state
  - Not do I/O operations --> but can describe it!!
  - Not randomize values --> only 'know' its input data
  - Not get current time --> only can access its input parameters
 but...
  - Consume time
  - Consume stack & heap

Purity gives us
  - Referential transparency
    -> an expression could be replaced with its value without change program behavior
    -> expression resolution could be done by sustitution
  - Equational reasoning (very difficult to reason with non-deterministic functions)
  - Easy paralellization (not locks required)
  - Compiler optimizations that can not be done in side-effecting functions.
--

                   \*Scala is an impure language.\s

<< http://degoes.net/articles/easy-monads
<< https://www.fpcomplete.com/blog/2017/04/pure-functional-programming
---
<< /Typed Functional Programming/Purity

Now you see that our previous code example 'object typedFP', was not pure fp,
because 'logger' function was NOT pure. Let's gonna change it!

```
object typedPureFP {
  sealed abstract class Effect[A](effect: () => A) {
    def unsafeRun: A = effect()

    def map[B](f: A => B): Effect[B] =
      Effect { f(effect()) }

    def flatMap[B](f: =>(A => Effect[B])): Effect[B] =
      Effect { f(effect()).unsafeRun }
  }
  object Effect {
    def apply[A](effect: => A): Effect[A] = new Effect.EffectImpl(() => effect)

    private class EffectImpl[A](effect: () => A) extends Effect(effect)
  }
  def pureProgram(logger: Any => Effect[Unit])(inc: Int => Int, mul: Int => Int):
    Int => Effect[Unit] = logger compose mul compose inc 

  val program = pureProgram {a => Effect( println(a) )} (_ + 2, _ * 3)

  // Main
  val effects: Effect[Unit] = program(0)
  // Compiler
  effects.unsafeRun
}

typedPureFP
```
---
<< /Typed Functional Programming/Purity + Effects

\*Will be this a problem?

```
import typedPureFP.Effect

def rec(n: Int, eff: Effect[Int]): Effect[Int] =
  n match {
    case 0 => eff
    case n => rec(n-1, eff.flatMap(v => Effect {v + 1} ))
  }

rec(100000, Effect {0}).unsafeRun
```
---
<< /Typed Functional Programming/Purity + Effects

```
sealed trait Trampoline[A]
object Trampoline {
  // The computation has finished with a result
  final case class Return[A](a: A) extends Trampoline[A]
  // The computation is suspended but we have a continuation 'k' to resume it.
  final case class Suspend[A](k: () => Trampoline[A]) extends Trampoline[A]
  // To get a Monad:
  // The result of the 'ta' computation is injected into the continuation 'k'
  final case class FlatMap[A, B](ta: Trampoline[A], k: A => Trampoline[B])
    extends Trampoline[B]

  def resume[A](ta: Trampoline[A]): Either[() => Trampoline[A], A] = ta match {
    case Return(v) => Right(v)
    case Suspend(k) => Left(k)
    case FlatMap(ta, f) => ta match {
      case Return(v) => resume(f(v)) // 'ta' is done => apply continuation
      case Suspend(k) => Left(() => FlatMap(k(), f)) // If 'ta' was suspended, continue it.
      case FlatMap(b, g) => resume(FlatMap(b, (x: Any) => FlatMap(g(x), f)))
    }
  }
  def runT[A](t: Trampoline[A]): A = resume(t) match {
    case Right(a) => a
    case Left(k) => runT(k())
  }
}
```
---
<< /Typed Functional Programming/Purity + Effects

```
  import Trampoline._

  def rec(n: Long, i: Int, f: Int => Int): Trampoline[Int] = n match {
    case 0 => Return(i)
    case n => Suspend(() => rec(n - 1, f(i), f))
  }

  val trec = rec(1000000, 0, (_: Int) + 1)

  val rRec = runT(FlatMap(trec, (v: Int) => Return(v * 2)))

  println(s"""${rRec}""")
```
---
